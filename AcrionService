package com.novaflow.action.service;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;

import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.MultipartBodyBuilder;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.util.UriComponentsBuilder;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.novaflow.action.config.ActionProperties;
import com.novaflow.action.dto.request.ActionRequest;
import com.novaflow.action.dto.request.ApiConfig;
import com.novaflow.action.dto.request.ApiConfig.PayloadType;
import com.novaflow.action.dto.response.ActionResponse;
import com.novaflow.action.dto.response.Metrics;
import com.novaflow.action.dto.response.RawResponse;
import com.novaflow.action.dto.response.ResponseBody;
import com.novaflow.action.dto.response.ResponseBody.BodyMode;
import com.novaflow.action.dto.response.TokenCallInfo;
import com.novaflow.action.exception.ActionException;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class ActionExecutorService {

    private final WebClient.Builder webClientBuilder;
    private final ActionProperties properties;
    private final OAuthTokenService oAuthTokenService;
    private final OutboundSecurityService securityService;
    private final FileService fileService;
    private final ResponseExtractionService extractionService;
    private final ObjectMapper objectMapper;

    // NEW: JDK HttpClient based service for presigned uploads
    private final PresignedHttpService presignedHttpService;

    public Mono<ActionResponse> execute(ActionRequest request) {
        String requestId = UUID.randomUUID().toString();
        String correlationId = resolveCorrelationId(request);
        long startTime = System.currentTimeMillis();
        AtomicLong tokenFetchMs = new AtomicLong(0);
        AtomicLong bytesSent = new AtomicLong(0);
        AtomicLong bytesReceived = new AtomicLong(0);

        log.info("Executing action request: {} correlation: {}", requestId, correlationId);

        if (request.getRequest() != null && request.getRequest().isDryRun()) {
            return handleDryRun(requestId, correlationId, request);
        }

        ApiConfig api = request.getApi();
        validateRequest(api);

        int timeout = Math.min(api.getRequestTimeoutSec(), properties.getLimits().getMaxTimeoutSec());

        return oAuthTokenService.getToken(request.getAuthConfig(), timeout)
            .doOnNext(tokenResult -> {
                if (tokenResult.tokenCallInfo().isUsed() && !tokenResult.tokenCallInfo().isCached()) {
                    tokenFetchMs.set(System.currentTimeMillis() - startTime);
                }
            })
            .flatMap(tokenResult ->
                executeTargetCall(request, tokenResult.accessToken(), correlationId, timeout, bytesSent, bytesReceived)
                    .map(rawResponse -> buildResponse(
                        requestId, correlationId, startTime,
                        tokenResult.tokenCallInfo(),
                        rawResponse, request,
                        tokenFetchMs.get(), bytesSent.get(), bytesReceived.get()
                    ))
            )
            .onErrorResume(ex -> handleError(requestId, correlationId, startTime, ex));
    }

    private void validateRequest(ApiConfig api) {
        securityService.validateUrl(api.getUrl());
        securityService.validateMethod(api.getMethod());

        if (isBodylessMethod(api.getMethod()) && api.getPayloadType() != PayloadType.NONE) {
            if (api.getPayloadType() != null && api.getPayloadType() != PayloadType.NONE) {
                log.warn("Method {} should not have a payload, ignoring payload_type", api.getMethod());
            }
        }
    }

    private boolean isBodylessMethod(ApiConfig.HttpMethod method) {
        return method == ApiConfig.HttpMethod.GET ||
               method == ApiConfig.HttpMethod.HEAD ||
               method == ApiConfig.HttpMethod.OPTIONS;
    }

    private String resolveCorrelationId(ActionRequest request) {
        if (request.getRequest() != null && StringUtils.hasText(request.getRequest().getCorrelationId())) {
            return request.getRequest().getCorrelationId();
        }
        return UUID.randomUUID().toString();
    }

    private Mono<ActionResponse> handleDryRun(String requestId, String correlationId, ActionRequest request) {
        log.info("Dry run mode - validating request without execution");

        return Mono.just(ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(true)
            .correlationId(correlationId)
            .tokenCall(TokenCallInfo.builder().used(false).build())
            .rawResponse(RawResponse.builder()
                .status(0)
                .body(ResponseBody.builder()
                    .mode(BodyMode.TEXT)
                    .text("DRY_RUN - Request validated successfully")
                    .build())
                .build())
            .metrics(Metrics.builder().durationMs(0).build())
            .build());
    }

    private Mono<RawResponse> executeTargetCall(
            ActionRequest request,
            String accessToken,
            String correlationId,
            int timeout,
            AtomicLong bytesSent,
            AtomicLong bytesReceived
    ) {
        ApiConfig api = request.getApi();

        String url = buildUrl(api, correlationId);
        log.debug("Target URL: {}", url);

        return fileService.loadFileInput(request.getFileInput())
            .defaultIfEmpty(new FileService.FileContent(null, null, null))
            .flatMap(fileContent -> {

                // ðŸ”¥ MINIMAL CHANGE: if presigned step, use HttpClient service instead of WebClient
                if (api.isUseHttpClient()) {
                    return executePresignedWithHttpClient(api, url, fileContent, correlationId, timeout, bytesSent, bytesReceived);
                }

                // existing WebClient path unchanged
                WebClient.RequestBodySpec requestSpec = webClientBuilder.build()
                    .method(HttpMethod.valueOf(api.getMethod().name()))
                    .uri(url);

                addHeaders(requestSpec, api, accessToken, correlationId, true);

                WebClient.RequestHeadersSpec<?> finalSpec = addBody(requestSpec, api, fileContent, bytesSent);

                return finalSpec
                    .exchangeToMono(response -> handleResponse(response, request.getFileOutput(),
                        request.getResponseHandling(), bytesReceived))
                    .timeout(Duration.ofSeconds(timeout))
                    .onErrorMap(ex -> {
                        if (ex instanceof java.util.concurrent.TimeoutException) {
                            return new ActionException("TIMEOUT", "Request timed out after " + timeout + " seconds");
                        }
                        return ex;
                    });
            });
    }

    /**
     * Presigned URL execution via JDK HttpClient (no WebClient)
     * IMPORTANT: we skip Authorization header by default (presigned URLs usually don't want it).
     */
    private Mono<RawResponse> executePresignedWithHttpClient(
            ApiConfig api,
            String url,
            FileService.FileContent fileContent,
            String correlationId,
            int timeout,
            AtomicLong bytesSent,
            AtomicLong bytesReceived
    ) {
        HttpHeaders headers = new HttpHeaders();
        // includeAuth=false to avoid adding Bearer/Basic to presigned S3 URL calls
        addHeaders(headers, api, null, correlationId, false);

        // Build body bytes using your existing payload rules (minimal: reuse file bytes for FILE_BYTES)
        byte[] bodyBytes = buildBodyBytesForHttpClient(api, fileContent, bytesSent);

        HttpMethod method = HttpMethod.valueOf(api.getMethod().name());

        return presignedHttpService.exchangeBytes(method, url, headers, bodyBytes)
                .timeout(Duration.ofSeconds(timeout))
                .onErrorMap(ex -> {
                    if (ex instanceof java.util.concurrent.TimeoutException) {
                        return new ActionException("TIMEOUT", "Request timed out after " + timeout + " seconds");
                    }
                    return ex;
                })
                .map(resp -> {
                    byte[] respBytes = (resp.bodyBytes() == null) ? new byte[0] : resp.bodyBytes();
                    bytesReceived.set(respBytes.length);

                    Map<String, String> outHeaders = new HashMap<>();
                    resp.headers().map().forEach((k, vals) -> {
                        if (vals != null && !vals.isEmpty()) outHeaders.put(k, vals.get(0));
                    });

                    // For S3 PUT uploads the response body is often empty; keep it safe
                    ResponseBody body = buildResponseBody(respBytes, outHeaders, null);

                    return RawResponse.builder()
                            .status(resp.status())
                            .headers(outHeaders)
                            .body(body)
                            .build();
                });
    }

    private byte[] buildBodyBytesForHttpClient(ApiConfig api, FileService.FileContent fileContent, AtomicLong bytesSent) {
        PayloadType payloadType = api.getPayloadType() != null ? api.getPayloadType() : PayloadType.NONE;

        if (isBodylessMethod(api.getMethod())) {
            return null;
        }

        return switch (payloadType) {
            case FILE_BYTES -> {
                if (fileContent.bytes() == null) {
                    throw new ActionException("FILE_MISSING", "FILE_BYTES payload type requires file_input");
                }
                bytesSent.set(fileContent.bytes().length);
                yield fileContent.bytes();
            }
            case TEXT -> {
                if (!StringUtils.hasText(api.getPayloadText())) {
                    bytesSent.set(0);
                    yield null;
                }
                byte[] b = api.getPayloadText().getBytes(StandardCharsets.UTF_8);
                bytesSent.set(b.length);
                yield b;
            }
            case JSON -> {
                if (api.getPayload() == null) {
                    bytesSent.set(0);
                    yield null;
                }
                try {
                    byte[] b = objectMapper.writeValueAsBytes(api.getPayload());
                    bytesSent.set(b.length);
                    yield b;
                } catch (JsonProcessingException e) {
                    throw new ActionException("PAYLOAD_INVALID", "Failed to serialize JSON payload");
                }
            }
            case FORM_URLENCODED -> {
                if (!(api.getPayload() instanceof Map)) {
                    bytesSent.set(0);
                    yield null;
                }
                @SuppressWarnings("unchecked")
                Map<String, Object> payload = (Map<String, Object>) api.getPayload();
                StringBuilder sb = new StringBuilder();
                payload.forEach((k, v) -> {
                    if (k == null || v == null) return;
                    if (sb.length() > 0) sb.append("&");
                    sb.append(urlEncode(k)).append("=").append(urlEncode(String.valueOf(v)));
                });
                byte[] b = sb.toString().getBytes(StandardCharsets.UTF_8);
                bytesSent.set(b.length);
                yield b;
            }
            // Minimal: multipart via HttpClient not needed for presigned upload typically.
            // If you need it, tell me and Iâ€™ll add multipart bytes here too.
            case MULTIPART_FORM -> throw new ActionException("UNSUPPORTED",
                    "MULTIPART_FORM with HttpClient not enabled in minimal presigned mode");
            case NONE -> null;
        };
    }

    private static String urlEncode(String s) {
        return java.net.URLEncoder.encode(s, StandardCharsets.UTF_8);
    }

    private String buildUrl(ApiConfig api, String correlationId) {
        UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(api.getUrl());

        if (api.getQuery() != null) {
            api.getQuery().forEach(builder::queryParam);
        }

        if (api.isIncludeCorrelationId()) {
            builder.queryParam("correlation_id", correlationId);
        }

        if (api.isIncludeAsofDate()) {
            String asofDate = api.getAsofDate() != null ? api.getAsofDate() :
                LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE);
            builder.queryParam("asof_date", asofDate);
        }

        return builder.build().toUriString();
    }

    // Existing method kept, but now delegates to shared logic
    private void addHeaders(WebClient.RequestBodySpec requestSpec, ApiConfig api,
                           String accessToken, String correlationId, boolean includeAuth) {
        HttpHeaders headers = new HttpHeaders();
        addHeaders(headers, api, accessToken, correlationId, includeAuth);
        requestSpec.headers(h -> h.addAll(headers));
    }

    // NEW overload used by HttpClient path (and by WebClient via adapter)
    private void addHeaders(HttpHeaders headers, ApiConfig api,
                            String accessToken, String correlationId, boolean includeAuth) {
        if (api.getHeaders() != null) {
            api.getHeaders().forEach((name, value) -> {
                if (!securityService.isHeaderForbidden(name)) {
                    headers.add(name, value);
                } else {
                    log.debug("Skipping forbidden header: {}", name);
                }
            });
        }

        if (includeAuth) {
            if (StringUtils.hasText(accessToken)) {
                headers.set(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken);
            } else if (StringUtils.hasText(api.getBearerToken())) {
                headers.set(HttpHeaders.AUTHORIZATION, "Bearer " + api.getBearerToken());
            } else if (api.getBasicAuth() != null &&
                    StringUtils.hasText(api.getBasicAuth().getUsername())) {
                String credentials = api.getBasicAuth().getUsername() + ":" + api.getBasicAuth().getPassword();
                String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
                headers.set(HttpHeaders.AUTHORIZATION, "Basic " + encoded);
            } else if (StringUtils.hasText(api.getCredentialRef())) {
                ActionProperties.CredentialEntry cred = properties.getCredentials().get(api.getCredentialRef());
                if (cred != null && StringUtils.hasText(cred.getUsername())) {
                    String credentials = cred.getUsername() + ":" + cred.getPassword();
                    String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
                    headers.set(HttpHeaders.AUTHORIZATION, "Basic " + encoded);
                }
            }
        }

        if (api.isIncludeCorrelationId()) {
            headers.add("X-Correlation-ID", correlationId);
        }
    }

    // Your existing addBody(...) unchanged (WebClient only)
    private WebClient.RequestHeadersSpec<?> addBody(WebClient.RequestBodySpec requestSpec,
                                                   ApiConfig api,
                                                   FileService.FileContent fileContent,
                                                   AtomicLong bytesSent) {
        PayloadType payloadType = api.getPayloadType() != null ? api.getPayloadType() : PayloadType.NONE;

        if (isBodylessMethod(api.getMethod())) {
            return requestSpec;
        }

        return switch (payloadType) {
            case JSON -> {
                if (api.getPayload() != null) {
                    try {
                        byte[] jsonBytes = objectMapper.writeValueAsBytes(api.getPayload());
                        bytesSent.set(jsonBytes.length);
                        yield requestSpec
                            .contentType(MediaType.APPLICATION_JSON)
                            .bodyValue(api.getPayload());
                    } catch (JsonProcessingException e) {
                        throw new ActionException("PAYLOAD_INVALID", "Failed to serialize JSON payload");
                    }
                }
                yield requestSpec;
            }
            case TEXT -> {
                if (StringUtils.hasText(api.getPayloadText())) {
                    byte[] textBytes = api.getPayloadText().getBytes(StandardCharsets.UTF_8);
                    bytesSent.set(textBytes.length);
                    yield requestSpec
                        .contentType(MediaType.TEXT_PLAIN)
                        .bodyValue(api.getPayloadText());
                }
                yield requestSpec;
            }
            case FORM_URLENCODED -> {
                if (api.getPayload() instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> payload = (Map<String, Object>) api.getPayload();
                    MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
                    payload.forEach((k, v) -> formData.add(k, String.valueOf(v)));
                    yield requestSpec
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .body(BodyInserters.fromFormData(formData));
                }
                yield requestSpec;
            }
            case MULTIPART_FORM -> {
                MultipartBodyBuilder builder = new MultipartBodyBuilder();

                if (api.getPayload() instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> payload = (Map<String, Object>) api.getPayload();
                    payload.forEach((k, v) -> builder.part(k, String.valueOf(v)));
                }

                if (fileContent.bytes() != null) {
                    String filename = fileContent.filename() != null ? fileContent.filename() : "file";
                    String contentType = fileContent.contentType() != null ? fileContent.contentType() : "application/octet-stream";
                    bytesSent.addAndGet(fileContent.bytes().length);
                    builder.part("file", new ByteArrayResource(fileContent.bytes()) {
                        @Override
                        public String getFilename() {
                            return filename;
                        }
                    }).contentType(MediaType.parseMediaType(contentType));
                }

                yield requestSpec
                    .contentType(MediaType.MULTIPART_FORM_DATA)
                    .body(BodyInserters.fromMultipartData(builder.build()));
            }
            case FILE_BYTES -> {
                if (fileContent.bytes() != null) {
                    bytesSent.set(fileContent.bytes().length);
                    String contentType = fileContent.contentType() != null ? fileContent.contentType() : "application/octet-stream";
                    yield requestSpec
                        .contentType(MediaType.parseMediaType(contentType))
                        .bodyValue(fileContent.bytes());
                }
                throw new ActionException("FILE_MISSING", "FILE_BYTES payload type requires file_input");
            }
            case NONE -> requestSpec;
        };
    }

    private Mono<RawResponse> handleResponse(ClientResponse response, com.novaflow.action.dto.request.FileOutputConfig fileOutput,
                                            com.novaflow.action.dto.request.ResponseHandlingConfig responseHandling,
                                            AtomicLong bytesReceived) {
        int status = response.statusCode().value();
        Map<String, String> headers = new HashMap<>();
        response.headers().asHttpHeaders().forEach((name, values) -> {
            if (!values.isEmpty()) {
                headers.put(name, values.get(0));
            }
        });

        long contentLength = response.headers().contentLength().orElse(-1);
        long maxBytes = properties.getLimits().getMaxResponseBytes();

        if (fileOutput != null && fileOutput.getMode() == com.novaflow.action.dto.request.FileOutputConfig.FileOutputMode.STREAM_TO_FILE) {
            return fileService.saveToFile(fileOutput, response.bodyToFlux(org.springframework.core.io.buffer.DataBuffer.class))
                .map(savedFile -> {
                    bytesReceived.set(savedFile.getSizeBytes() != null ? savedFile.getSizeBytes() : 0);
                    return RawResponse.builder()
                        .status(status)
                        .headers(headers)
                        .body(ResponseBody.builder()
                            .mode(BodyMode.STREAMED_TO_FILE)
                            .savedFile(savedFile)
                            .build())
                        .build();
                });
        }

        if (contentLength > maxBytes) {
            return response.releaseBody()
                .thenReturn(RawResponse.builder()
                    .status(status)
                    .headers(headers)
                    .body(ResponseBody.builder()
                        .mode(BodyMode.OMITTED_TOO_LARGE)
                        .text("Response too large: " + contentLength + " bytes")
                        .build())
                    .build());
        }

        return response.bodyToMono(byte[].class)
            .defaultIfEmpty(new byte[0])
            .map(bodyBytes -> {
                bytesReceived.set(bodyBytes.length);
                return buildResponseBody(bodyBytes, headers, responseHandling);
            })
            .map(body -> RawResponse.builder()
                .status(status)
                .headers(headers)
                .body(body)
                .build());
    }

    private ResponseBody buildResponseBody(byte[] bodyBytes, Map<String, String> headers,
                                          com.novaflow.action.dto.request.ResponseHandlingConfig responseHandling) {
        String contentType = headers.getOrDefault("Content-Type", "");
        String bodyText = new String(bodyBytes, StandardCharsets.UTF_8);

        if (contentType.contains("application/json")) {
            try {
                Object json = objectMapper.readValue(bodyBytes, Object.class);
                return ResponseBody.builder()
                    .mode(BodyMode.JSON)
                    .json(json)
                    .build();
            } catch (Exception e) {
                log.debug("Failed to parse JSON response: {}", e.getMessage());
            }
        }

        if (contentType.contains("text/") || contentType.contains("application/xml")) {
            return ResponseBody.builder()
                .mode(BodyMode.TEXT)
                .text(bodyText)
                .build();
        }

        return ResponseBody.builder()
            .mode(BodyMode.BASE64)
            .base64(Base64.getEncoder().encodeToString(bodyBytes))
            .build();
    }

    private ActionResponse buildResponse(String requestId, String correlationId, long startTime,
                                         TokenCallInfo tokenCall, RawResponse rawResponse,
                                         ActionRequest request, long tokenFetchMs,
                                         long bytesSent, long bytesReceived) {
        Map<String, Object> parsedOutput = new HashMap<>();

        if (request.getResponseHandling() != null && request.getResponseHandling().isParse()) {
            String bodyText = extractBodyText(rawResponse);
            parsedOutput = extractionService.extract(
                request.getResponseHandling(),
                rawResponse.getStatus(),
                rawResponse.getHeaders(),
                bodyText
            );
        }

        long totalDuration = System.currentTimeMillis() - startTime;

        return ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(true)
            .correlationId(correlationId)
            .tokenCall(tokenCall)
            .rawResponse(rawResponse)
            .parsedOutput(parsedOutput.isEmpty() ? null : parsedOutput)
            .metrics(Metrics.builder()
                .durationMs(totalDuration)
                .tokenFetchMs(tokenFetchMs > 0 ? tokenFetchMs : null)
                .targetCallMs(totalDuration - tokenFetchMs)
                .bytesSent(bytesSent)
                .bytesReceived(bytesReceived)
                .build())
            .build();
    }

    private String extractBodyText(RawResponse rawResponse) {
        if (rawResponse.getBody() == null) return null;

        ResponseBody body = rawResponse.getBody();

        if (body.getJson() != null) {
            try {
                return objectMapper.writeValueAsString(body.getJson());
            } catch (JsonProcessingException e) {
                return null;
            }
        }

        return body.getText();
    }

    private Mono<ActionResponse> handleError(String requestId, String correlationId,
                                            long startTime, Throwable ex) {
        log.error("Action execution failed: {}", ex.getMessage());

        String code = "EXECUTION_FAILED";
        String message = ex.getMessage();

        if (ex instanceof ActionException actionEx) {
            code = actionEx.getCode();
        }

        return Mono.just(ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(false)
            .correlationId(correlationId)
            .error(com.novaflow.action.dto.response.ErrorInfo.builder()
                .code(code)
                .message(message)
                .build())
            .metrics(Metrics.builder()
                .durationMs(System.currentTimeMillis() - startTime)
                .build())
            .build());
    }
}
